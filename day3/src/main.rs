use std::fs;

type Item = char;
type Compartment = Vec<Item>; // A compartment is a list of items
type Elf = Rucksack; // We'll consider an elf is his Rucksack

// A Rucksack has two compartments
#[derive(Debug, Clone)]
struct Rucksack {
    first_compartment: Compartment,
    second_compartment: Compartment,
}

#[derive(Debug, Clone)]
struct Group {
    elves: Vec<Elf>,
    common_item: Option<Item>,
}

// Associated functions for type Rucksack
impl Rucksack {
    // We create a new Rucksack
    pub fn new(contents: &str) -> Option<Rucksack> {
        if contents == "" {
            // If the line we get sent is empty None is returned
            return None;
        }

        // We divide our content in two equal parts
        let first_compartment = contents[..contents.len() / 2].chars().collect();
        let second_compartment = contents[contents.len() / 2..].chars().collect();

        // Let's return Some Rucksack with what we divided as content
        Some(Rucksack {
            first_compartment,
            second_compartment,
        })
    }

    // Filters out the common item of our two compartments
    pub fn get_common_item(&self) -> Item {
        let res: Vec<&Item> = self
            .first_compartment
            .iter()
            .filter(|item| self.second_compartment.contains(item))
            .collect();

        // Since there might be multiple of our common item we only give back the first one
        // There's always a first one because we treat the case of the empty string somewhere else
        *res[0]
    }
}

impl Group {
    pub fn new() -> Group {
        Group {
            elves: vec![],
            common_item: None,
        }
    }

    pub fn add_elf(&mut self, elf: &Elf) {
        self.elves.push(elf.clone());
        if self.common_item == None {
            self.common_item = Some(elf.get_common_item())
        }
    }
}

// Return the priority value of our item (technically we can't panic but still never too careful)
fn get_item_priority(item: Item) -> u32 {
    if item.is_uppercase() {
        return item as u32 - 64 + 26;
    } else if item.is_lowercase() {
        return item as u32 - 96;
    } else {
        panic!("Unable to parse item {item}");
    }
}

fn get_group_item_priority(group: &Group) -> u32 {
    if let Some(item) = group.common_item {
        get_item_priority(item)
    } else {
        0
    }
}

fn part1(input: &str) -> u32 {
    let contents = fs::read_to_string(input).unwrap(); // Get the content of our file

    let contents = contents.split("\n"); // Split it by line break

    contents
        .map(|line| {
            // for each line of our file
            if let Some(sack) = Rucksack::new(line) {
                // if Some Rucksack can be generated by it
                get_item_priority(sack.get_common_item()) // We get back the common item of the
                                                          // sack priority
            } else {
                0 // If it's the None variant we send back 0 to not break our sum
            }
        })
        .sum::<u32>() // Sum all that up and there's our answer
}

fn part2(input: &str) -> u32 {
    let contents = fs::read_to_string(input).unwrap();

    let contents = contents.split("\n");

    0
}

fn main() {
    println!("{}", part1("input.txt"));
    println!("{}", part2("input.txt"));
}

#[cfg(test)]
mod tests {
    use crate::{part1, part2};

    #[test]
    fn test_part1() {
        assert_eq!(part1("inputtest.txt"), 157)
    }

    #[test]
    fn test_part2() {
        assert_eq!(part2("inputtest.txt"), 70)
    }
}
